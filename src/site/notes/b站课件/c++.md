---
{"dg-publish":true,"permalink":"/b站课件/c++/","dgPassFrontmatter":true}
---


# 简介
## C++ 简介
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
	**静态类型的**：这意味着在编译时，所有的变量和函数的类型都会被检查和确定，而不是在运行时。
	 **编译式的**：C++程序需要被编译成机器码，然后才能在计算机上运行。
	 **通用的**：C++是一种通用编程语言，可以用于多种不同的应用领域，比如系统软件、游戏开发、高性能服务器和客户端应用等。
	 **大小写敏感的**：在C++中，变量名的大小写是区分的，例如variable和Variable是两个不同的变量。
	 **不规则的**：C++语言的语法和规则与其他一些语言相比，可能不那么直观或一致，这使得学习曲线相对陡峭。
	 **支持过程化编程、面向对象编程和泛型编程**：C++支持多种编程范式，包括传统的基于过程的编程（如C语言），面向对象编程（OOP），以及泛型编程（使用模板）。
C++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。

C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。

C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
##  面向对象程序设计
C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：
	**封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
	**继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
	**多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
	**抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形 成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。
## 标准库
标准的 C++ 由三个重要部分组成：
	核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
	C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
	标准模板库（STL），提供了大量的方法，用于操作数据结构等。
# C++ 环境设置
安装vs2022
# C++ 基本语法

## C++ 程序结构

让我们看一段简单的代码，可以输出单词 _Hello World_。
```c
#include <iostream> 
using namespace std; 
// main() 是程序开始执行的地方 
int main() 
{ 
	cout << "Hello World"; // 输出 Hello World 
	return 0; 
}
```
解释
	**头文件**：C++语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。在这段程序中，包含了头文件`<iostream>`，它允许程序使用输入输出流，如cout进行输出。
	**命名空间**：using namespace std;这行代码告诉编译器使用std命名空间。命名空间是C++中一个相对新的概念，用于避免名称冲突，std是标准库的命名空间。
	**单行注释**：// main() 是程序开始执行的地方是一个单行注释。在C++中，单行注释以//开头，在行末结束，编译器会忽略这些注释。
	**主函数**：int main()是主函数，它是程序的入口点，程序从这里开始执行。
	**输出消息**：cout << "Hello World";这行代码会在屏幕上显示消息"Hello World"。cout是标准输出流，<<是插入操作符，用于将数据发送到输出流。
	**返回值**：return 0;这行代码终止main()函数，并向调用进程返回值0。在C++中，返回0通常表示程序成功执行结束。
## C++ 中的分号 & 语句块

在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。
	C++ 语言中，一个逻辑实体可以是一个表达式、一个控制流语句、一个函数定义等。每个逻辑实体都是一个独立的代码块，它完成了一个明确的任务。
	在 C++ 中，每个逻辑实体的结束都需要用分号来标识，这表明该逻辑实体的结束，并且告诉编译器下一个逻辑实体的开始。分号在这里起到了语句界定的作用。
例如，下面是三个不同的语句：
```c
x = y; //一个赋值操作
y = y+1; //一个赋值操作
add(x, y); //一个函数调用
```
语句块是一组使用大括号括起来的按逻辑连接的语句,例如：
```c
{ 
	cout << "Hello World"; // 使用了C++标准库中的cout对象来输出字符串"Hello World"到标准输出（通常是屏幕）。<<是C++中的流插入操作符，用于将数据发送到输出流。
	return 0; 
}
```
## C++ 标识符
C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。
C++ 标识符内不允许出现标点字符，比如 @、& 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。
## C++ 的关键字（保留字）完整介绍
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112102426.png)
**1. asm**

asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。

**2. auto**

auto（自动，automatic）是存储类型标识符，表明变量"自动"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。

**3. bool**

bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。

**4. break**

break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。

**5. case**

用于 switch 语句中，用于判断不同的条件类型。

**6. catch**

catch 和 try 语句一起用于异常处理。

**7. char**

char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ' 括起来。

**8.class**

class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。

**9. const**

const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。

**10. const_cast用法：**

const_cast<type_id> (expression)

该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

**11. continue**

continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是"继续循环"之意，不是 break（跳出）。

**12. default**

default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。

**13. delete**

delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 \[]，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。

**14. do**

do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。

**15. double**

double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。

**16. dynamic_cast**

dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。

**17. else**

else 紧跟在 if 后面，用于对 if 不成立的情况的选择。

**18. enum**

enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。

**19. explicit**

explicit（显式的）的作用是"禁止单参数构造函数"被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。

**20. export**

为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。

**21. extern**

extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。

**22. false**

false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。

**23. float**

float（浮点数），C++ 中的基本数据结构，精度小于 double。

**24. for**

for 是 C++ 中的循环结构之一。

**25. friend**

friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。

**26. goto**

goto（转到），用于无条件跳转到某一标号处开始执行。

**27. if**

if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。

**28. inline**

inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。

**29. int**

int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。

**30. long**

long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。

**31. mutable**

mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。

**32. namespace**

namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。

**33. new**

new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建

**34. operator**

operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。

**35. private**

private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。

**36. protected**

protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。

**37. public**

public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类

**38.register**

register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。

**39. reinterpret_cast**

用法：

reinpreter_cast\<type-id> (expression)

type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

**40. return**

return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。

**41. short**

short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。

**42. signed**

signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。

**43. sizeof**

由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。

**44. static**

static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为"文件作用域"。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。

**45. static_cast**

用法：

static_cast < type-id > ( expression ) 

该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。

**46. struct**

struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。

**47. switch**

switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。

**48. template**

template（模板），C++ 中泛型机制的实现。

**49. this**

this 返回调用者本身的指针。

**50. throw**

throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字"抛出"一个异常。

**51. true**

true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。

**52. try**

try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。

**53. typedef**

typedef（类型定义，type define），其格式为：

typedef  类型 定义名;

类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。

**54. typeid**

指出指针或引用指向的对象的实际派生类型。

**55. typename**

typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。

**56. union**

union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。

**57. unsigned**

unsigned（无符号），表明该类型是无符号数，和 signed 相反。

**58. using**

表明使用 namespace。

**59. virtual**

virtual（虚的），C++ 中用来实现多态机制。

**60. void**

void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。

**61. volatile**

volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变，声明时的语法如下：

int volatile nVint;

**62. wchar_t**

wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。
# C++ 注释
- // 一般用于单行注释。对于当前行或选定的多行代码，按下 Ctrl + /（斜杠）可以添加单行注释符号。再次按下 Ctrl + / 可以取消这些注释
- /* ... \*/ 一般用于多行注释。 Ctrl + K，再按 Ctrl + C。按下 Ctrl + K，再按 Ctrl + U取消注释。
# C++ 数据类型
使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。

您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。
## 基本的内置类型

C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。这里列出了几种常见的数据类型及其对应的关键字：
1. **布尔型（bool）**：用于表示逻辑值，只有两个可能的值：真（true）和假（false）。
    
2. **字符型（char）**：用于存储单个字符，通常是8位的。
    
3. **整型（int）**：用于存储整数，可以是正数、负数或零。
    
4. **浮点型（float）**：用于存储单精度的浮点数，即小数点后有有限位数的数。
    
5. **双浮点型（double）**：用于存储双精度的浮点数，即小数点后位数比float多的数，精度更高。
    
6. **无类型（void）**：表示没有值或没有类型，通常用于函数声明中，表示该函数不返回任何值。
    
7. **宽字符型（wchar_t）**：用于存储宽字符，可以表示更广泛的字符集，通常是16位或32位的。
一些基本类型可以使用一个或多个类型修饰符进行修饰：

1. **signed**：这个修饰符用于指定数值类型是有符号的，即可以表示正数和负数。如果一个数值类型没有明确指定是signed或unsigned，那么默认情况下它是signed的。例如，signed int就是一个有符号的整型。
    
2. **unsigned**：这个修饰符用于指定数值类型是无符号的，即只能表示非负数（正数和零）。使用unsigned修饰符的类型，其能表示的数值范围是相应有符号类型的正数部分。例如，unsigned int就是一个无符号的整型，它只能存储非负整数。
    
3. **short**：这个修饰符用于指定数值类型是短整型。short类型的变量占用的内存空间比标准整型（int）小，通常short是16位的，而int可能是16位或32位，这取决于编译器和硬件架构。例如，short int就是一个短整型。
    
4. **long**：这个修饰符用于指定数值类型是长整型。long类型的变量占用的内存空间比标准整型（int）大，通常long是32位或64位，这也取决于编译器和硬件架构。例如，long int就是一个长整型。
    

这些修饰符可以单独使用，也可以组合使用。例如，unsigned long int就是一个无符号的长整型，它可以存储更大的非负整数范围。这些修饰符允许程序员根据需要选择最合适的数据类型，以优化内存使用和程序性能。
## typedef 声明

您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：

typedef type newname; 

例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：

typedef int feet;

现在，下面的声明是完全合法的，它创建了一个整型变量 distance：

feet distance;
## 枚举类型

枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。

如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。

创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：
```
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```
默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。
## 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

### 静态转换（Static Cast）

静态转换是将一种数据类型的值强制转换为另一种数据类型的值。

静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。
```c
int i = 10;
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```
静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。

### 动态转换（Dynamic Cast）

动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。
```c
class Base {};
class Derived : public Base {};
Base* ptr_base = new Derived;
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```

### 常量转换（Const Cast）

常量转换用于将 const 类型的对象转换为非 const 类型的对象。

常量转换只能用于转换掉 const 属性，不能改变对象的类型。
```c
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

### 重新解释转换（Reinterpret Cast）

重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。

重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。
```c
int i = 10;
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```

# C++ 变量类型
变量其实只不过是程序可操作的存储区的名称。在 C++ 中，有多种变量类型可用于存储不同种类的数据。变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。

大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等
1. 整数类型（Integer Types）：
    
    - `int`：用于表示整数，通常占用4个字节。
    - `short`：用于表示短整数，通常占用2个字节。
    - `long`：用于表示长整数，通常占用4个字节。
    - `long long`：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
    
    - `float`：用于表示单精度浮点数，通常占用4个字节。
    - `double`：用于表示双精度浮点数，通常占用8个字节。
    - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
    
    - `char`：用于表示字符，通常占用1个字节。
    - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
    - `char16_t`：用于表示16位Unicode字符，占用2个字节。
    - `char32_t`：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
    
    - `bool`：用于表示布尔值，只能取`true`或`false`。
5. 枚举类型（Enumeration Types）：
    
    - `enum`：用于定义一组命名的整数常量。
6. 指针类型（Pointer Types）：
    
    - `type*`：用于表示指向类型为`type`的对象的指针。
7. 数组类型（Array Types）：
    
    - `type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。
8. 结构体类型（Structure Types）：
    
    - `struct`：用于定义包含多个不同类型成员的结构。
9. 类类型（Class Types）：
    
    - `class`：用于定义具有属性和方法的自定义类型。
10. 共用体类型（Union Types）：
    
    - `union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。
在 C++ 中，类型的长度（即占用的字节数）取决于编译器和计算机架构，然而，C++ 标准规定了不同整数类型的最小范围，而不是具体的字节数，这是为了确保代码在不同的系统上都能正确运行。

请注意，以上类型的范围只是 C++ 标准规定的最小要求。

## C++ 中的变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112125658.png)
```c
extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

## C++ 中的左值（Lvalues）和右值（Rvalues）
C++ 中有两种类型的表达式：

- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。总结来说，左值和右值的主要区别在于左值可以被赋值，而右值不可以。左值指向内存位置，可以存储值；右值则是具体的数值，不能被赋值，只能被使用。

# C++ 变量作用域
一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
    
- 在函数参数的定义中声明的变量，称为**形式参数**。
    
- 在所有函数外部声明的变量，称为**全局变量**。
作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
    
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
    
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
    
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。
    

如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。

# C++ 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
## 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数常量的实例：
```c
212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
```
## 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：
```c
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```
## 布尔常量

布尔常量共有两个，它们都是标准的 C++ 关键字：

- **true** 值代表真。
- **false** 值代表假。

我们不应把 true 的值看成 1，把 false 的值看成 0。
## 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。
## 字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。
## 定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
	\#define identifier value
- 使用 **const** 关键字。
	const type variable = value;
# C++ 修饰符类型

C++ 允许在 **char、int 和 double** 数据类型前放置修饰符。

修饰符是用于改变变量类型的行为的关键字，它更能满足各种情境的需求。

下面列出了数据类型修饰符：

- signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。
    
- unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。
    
- short：表示变量的范围比 int 更小。short int 可以缩写为 short。
    
- long：表示变量的范围比 int 更大。long int 可以缩写为 long。
    
- long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。

修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。

这些修饰符也可以组合使用，修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。
## C++ 中的类型限定符

类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。
1. **const**：const 关键字用于定义常量，即一旦被初始化后，其值不能被修改。这有助于防止程序中意外改变变量的值，增加代码的安全性和稳定性。
    
2. **volatile**：volatile 关键字是一个类型修饰符，用于告诉编译器该变量的值可能会在程序的控制之外被改变，比如由硬件或其他线程。使用 volatile 可以防止编译器进行某些优化，确保每次访问变量时都从内存中读取其值。
    
3. **restrict**：restrict 关键字用于指针，表明这个指针是访问它所指向数据的唯一方式。这是C99标准中引入的，它可以帮助编译器更有效地优化代码，因为它知道没有其他指针可以访问同一块内存区域。
    
4. **mutable**：mutable 关键字用于类的成员变量，即使对象本身是常量（const），被 mutable 修饰的成员变量也可以被修改。这通常用于那些需要在对象的生命周期内改变值的成员变量，如缓存或时间戳。
    
5. **static**：static 关键字用于定义静态变量，这意味着变量的存储期为整个程序的运行期，并且只能在定义它的文件或函数内部访问。静态变量常用于保存全局状态或者实现函数内部的局部变量持久化。
# C++ 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期(范围指的是变量或函数可以在哪些地方被访问，生命周期则是指变量或函数在程序执行过程中存在的时间。)。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：
## static 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
## extern 存储类

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 _extern_ 来得到已定义的变量或函数的引用。可以这么理解，_extern_ 是用来在另一个文件中声明一个全局变量或函数。
## mutable 存储类

mutable 是一个关键字，用于修饰类的成员变量，使其能够在 const 成员函数中被修改。通常情况下，const 成员函数不能修改对象的状态，但如果某个成员变量被声明为 mutable，则可以在 const 函数中对其进行修改。

**特点：**

- **允许修改**：`mutable` 成员变量可以在 `const` 成员函数内被改变。
- **设计目的**：通常用于需要在不改变对象外部状态的情况下进行状态管理的场景，比如缓存、延迟计算等。
## thread_local 存储类

thread_local 是 C++11 引入的一种存储类，用于在多线程环境中管理线程特有的变量。

使用 thread_local 修饰的变量在每个线程中都有独立的实例，因此每个线程对该变量的操作不会影响其他线程。

- **独立性**：每个线程都有自己独立的变量副本，不同线程之间的读写操作互不干扰。
- **生命周期**：`thread_local` 变量在其线程结束时自动销毁。
- **初始化**：`thread_local` 变量可以进行静态初始化或动态初始化，支持在声明时初始化。

thread_local 适合用于需要存储线程状态、缓存或者避免数据竞争的场景，如线程池、请求上下文等。
# C++ 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符

# C++ while 循环
只要给定的条件为真，**while** 循环语句会重复执行一个目标语句。
## 语法

C++ 中 **while** 循环的语法：
```c
while(condition)
{
   statement(s);
}
```
在这里，**statement(s)** 可以是一个单独的语句，也可以是几个语句组成的代码块。**condition** 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。

当条件为假时，程序流将继续执行紧接着循环的下一条语句。
## 流程图

![C++ 中的 while 循环](https://www.runoob.com/wp-content/uploads/2014/09/BFE13459-897C-41A5-AE94-D71B0CA50FB6.jpg)

在这里，_while_ 循环的关键点是循环可能一次都不会执行。当条件被测试且结果为假时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句。
# C++ for 循环
**for** 循环允许您编写一个执行特定次数的循环的重复控制结构。

## 语法

C++ 中 **for** 循环的语法：
```c
for ( init; condition; increment )
{
   statement(s);
}

```
下面是 for 循环的控制流：

1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

## 流程图

![C++ 中的 for 循环](https://www.runoob.com/wp-content/uploads/2014/09/69978E61-0BA5-4D66-A115-D3AD15B16F47.jpg)
# C++ do...while 循环
不像 **for** 和 **while** 循环，它们是在循环头部测试循环条件。**do...while** 循环是在循环的尾部检查它的条件。

**do...while** 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。
## 语法

C++ 中 **do...while** 循环的语法：
```c
do
{
   statement(s);

}while( condition );

```
请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。

如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。

## 流程图

![C++ 中的 do...while 循环](https://www.runoob.com/wp-content/uploads/2014/09/B2FE1EC7-6477-439B-8F50-82D537673799.jpg)
# C++ break 语句
C++ 中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。
# C++ continue 语句

C++ 中的 **continue** 语句有点像 **break** 语句。但它不是强迫终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句会导致执行条件测试和循环增量部分。对于 **while** 和 **do...while** 循环，**continue** 语句会导致程序控制回到条件测试上。
# C++ goto 语句
**goto** 语句允许把控制无条件转移到同一函数内的被标记的语句。

注意：在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。
# C++ if 语句
## 语法

C++ 中 **if** 语句的语法：
```c
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
```
如果布尔表达式为 **true**，则 if 语句内的代码块将被执行。如果布尔表达式为 **false**，则 if 语句结束后的第一组代码（闭括号后）将被执行。

C 语言把任何**非零**和**非空**的值假定为 **true**，把**零**或 **null** 假定为 **false**。
## 流程图
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112132932.png)

# C++ if...else 语句
一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。
## 语法

C++ 中 **if...else** 语句的语法：
```c
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
else
{
   // 如果布尔表达式为假将执行的语句
}

```
如果布尔表达式为 **true**，则执行 **if** 块内的代码。如果布尔表达式为 **false**，则执行 **else** 块内的代码。

## 流程图

![C++ 中的 if...else 语句](https://www.runoob.com/wp-content/uploads/2014/09/if_else_statement.jpg)
# C++ switch 语句
在 C++ 中，switch 语句用于基于不同的条件执行不同的代码块，它通常用来替代一系列的 if-else 语句，使代码更清晰和易读。

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。
## 语法

C++ 中 **switch** 语句的语法：
```c
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```
**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 _继续_ 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。
## 流程图

![C++ 中的 switch 语句](https://www.runoob.com/wp-content/uploads/2014/09/switch_statement.jpg)
# C++ 函数

函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。
## 定义函数

C++ 中的函数定义的一般形式如下：
```c
return_type function_name( parameter list )
{
   body of the function
}
```
在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- 函数主体：函数主体包含一组定义函数执行任务的语句。
## 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

return_type function_name( parameter list );
当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。
## 调用函数

创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值
## 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。
## 参数的默认值

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。
# C++ 数组

C++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers\[0]、numbers\[1]、...、numbers\[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
## 声明数组

在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

type arrayName \[ arraySize ];

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

double balance\[10];

现在 _balance_ 是一个可用的数组，可以容纳 10 个类型为 double 的数字。
## 初始化数组

在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

double balance\[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 \[ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

double balance\[] = {1000.0, 2.0, 3.4, 7.0, 50.0};

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

balance\[4] = 50.0;

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://www.runoob.com/wp-content/uploads/2014/08/array_presentation.jpg)
## 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

double salary = balance\[9];
# C++ 指针

学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。
## 什么是指针？

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type \*var-name;

在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：
```c
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```
所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。
# C++ 结构体(struct)

C/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
## 定义结构

在 C++ 中，struct 语句用于定义结构体（structure）。

结构体是一种用户自定义的数据类型，用于将不同类型的数据组合在一起。与类（class）类似，结构体允许你定义成员变量和成员函数。

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
```c
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```
**type_name** 是结构体类型的名称，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。
**结构体优点：**

- **简单数据封装**：适合封装多种类型的简单数据，通常用于数据的存储。
- **轻量级**：相比 `class`，结构体语法更简洁，适合小型数据对象。
- **面向对象支持**：支持构造函数、成员函数和访问权限控制，可以实现面向对象的设计。

## 访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。
## 结构体与类的区别

在 C++ 中，struct 和 class 本质上非常相似，唯一的区别在于默认的访问权限：

- `struct` 默认的成员和继承是 `public`。
- `class` 默认的成员和继承是 `private`。

你可以将 `struct` 当作一种简化形式的 `class`，适合用于没有太多复杂功能的简单数据封装。
# C++ 类 & 对象

C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。

类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。
## C++ 类定义

定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。

定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112135506.png)
## 定义 C++ 对象

类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。
## 访问数据成员

类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112135617.png)
# C++ 类成员函数
类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。
```c
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
```
您也可以在类的外部使用**范围解析运算符 ::** 定义该函数，如下所示：
```c
double Box::getVolume(void)
{
    return length * breadth * height;
}
```
# C++ 类访问修饰符
数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。

一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。
```c
class Base {
 
   public:
 
  // 公有成员
 
   protected:
 
  // 受保护成员
 
   private:
 
  // 私有成员
 
};
```
## 公有（public）成员

**公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值
## 私有（private）成员

**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

默认情况下，类的所有成员都是私有的。
## protected（受保护）成员

protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。
## 继承中的特点

有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

- 1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
    
- 2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
    
- 3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private
    

但无论哪种继承方式，下面两点都没有改变：

- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
    
- 2.protected 成员可以被派生类访问。
# C++ 类构造函数 & 析构函数
## 类的构造函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。
## 带参数的构造函数

默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值
## 类的析构函数

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
# C++ 拷贝构造函数
**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
    
- 复制对象把它作为参数传递给函数。
    
- 复制对象，并从函数返回这个对象。
    

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：
```c
classname (const classname &obj) {
   // 构造函数的主体
}
```
在这里，**obj** 是一个对象引用，该对象是用于初始化另一个对象的。
# C++ 友元函数
类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**，如下所示：
```c
class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};

```
声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：
friend class ClassTwo;
# C++ 内联函数
C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。
# C++ this 指针
在 C++ 中，**this** 指针是一个特殊的指针，它指向当前对象。
在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。

**this**是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。

当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。

友元函数没有 **this** 指针，因为友元不是类的成员，只有成员函数才有 **this** 指针。
# C++ 指向类的指针
一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

在 C++ 中，指向类的指针指向一个类的对象，与普通的指针相似，指向类的指针可以用于访问对象的成员变量和成员函数。
# C++ 类的静态成员
我们可以使用 **static** 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112152411.png)
## 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。
# C++ 继承
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

继承代表了 **is a** 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
![image.png](https://raw.githubusercontent.com/Z-h-e-n-g-L-o-n-g/imgroom/main/obsidian/20241112152529.png)

```c
// 基类
class Animal {
    // eat() 函数
    // sleep() 函数
};


//派生类
class Dog : public Animal {
    // bark() 函数
};
```
## 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性，形式如下：
```cpp
// 基类
class Animal {
public:
    void eat() {
        // 动物吃东西的实现
    }
    void sleep() {
        // 动物睡觉的实现
    }
};

// 另一个基类
class Pet {
public:
    void play() {
        // 宠物玩耍的实现
    }
};

// 派生类
class Dog : public Animal, public Pet {
public:
    void bark() {
        // 狗叫的实现
    }
};
```
## 访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。
## 继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- 公有继承（public）：当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- 保护继承（protected）：当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- 私有继承（private）：当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。
# C++ 重载运算符和重载函数
C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。

## C++ 中的函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。
## C++ 中的运算符重载

您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。
Box operator+(const Box&);
声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：
Box operator+(const Box&, const Box&);
下面是不可重载的运算符列表：

- .：成员访问运算符
- .\*, ->\*：成员指针访问运算符
- ::：域运算符
- sizeof：长度运算符
- ?:：条件运算符
- \#： 预处理符号
# C++ 多态

**多态**按字面的意思就是多种形态。

当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

在 C++ 中，多态（Polymorphism）是面向对象编程的重要特性之一。

C++ 多态允许使用基类指针或引用来调用子类的重写方法，从而使得同一接口可以表现不同的行为。

多态使得代码更加灵活和通用，程序可以通过基类指针或引用来操作不同类型的对象，而不需要显式区分对象类型。这样可以使代码更具扩展性，在增加新的形状类时不需要修改主程序。

以下是多态的几个关键点：

**虚函数（Virtual Functions）**：

- 在基类中声明一个函数为虚函数，使用关键字`virtual`。
- 派生类可以重写（override）这个虚函数。
- 调用虚函数时，会根据对象的实际类型来决定调用哪个版本的函数。

**动态绑定（Dynamic Binding）**：

- 也称为晚期绑定（Late Binding），在运行时确定函数调用的具体实现。
- 需要使用指向基类的指针或引用来调用虚函数，编译器在运行时根据对象的实际类型来决定调用哪个函数。

**纯虚函数（Pure Virtual Functions）**：

- 一个包含纯虚函数的类被称为抽象类（Abstract Class），它不能被直接实例化。
- 纯虚函数没有函数体，声明时使用`= 0`。
- 它强制派生类提供具体的实现。

**多态的实现机制**：

- 虚函数表（V-Table）：C++运行时使用虚函数表来实现多态。每个包含虚函数的类都有一个虚函数表，表中存储了指向类中所有虚函数的指针。
- 虚函数指针（V-Ptr）：对象中包含一个指向该类虚函数表的指针。

**使用多态的优势**：

- **代码复用**：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码的复用。
- **扩展性**：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数。
- **解耦**：多态允许程序设计更加模块化，降低类之间的耦合度。

**注意事项**：

- 只有通过基类的指针或引用调用虚函数时，才会发生多态。
- 如果直接使用派生类的对象调用函数，那么调用的是派生类中的版本，而不是基类中的版本。
- 多态性需要运行时类型信息（RTTI），这可能会增加程序的开销。