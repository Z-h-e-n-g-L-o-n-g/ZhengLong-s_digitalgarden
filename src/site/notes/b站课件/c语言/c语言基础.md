---
{"dg-publish":true,"permalink":"/b站课件/c语言/c语言基础/","dgPassFrontmatter":true}
---


- 编译链接
- 16进制转2进制
- 计算机如何计算+-* /
- 小数转2进制
## 编译链接
### 编译（Compilation）

1. **语言转换**：编译器将高级语言（如C语言）编写的源代码转换成机器码或中间代码。机器码是计算机硬件可以直接执行的指令。
    
2. **错误检测**：编译过程中，编译器会检查语法错误、类型不匹配、未定义的变量等编程错误，帮助开发者在早期发现并修复这些问题。
    
3. **优化**：编译器会对代码进行优化，以提高程序的执行效率。这可能包括消除不必要的计算、改进内存使用、循环展开等。
    
4. **代码转换**：编译器将源代码转换为可重定位的目标代码。目标代码包含了程序的逻辑和数据，但尚未解决程序中引用的其他代码或库的地址。
    

### 链接（Linking）

1. **解决外部引用**：在编译过程中，编译器生成的目标代码可能包含对其他文件或库的引用。链接器负责解析这些引用，将它们与实际的代码或库链接起来。
    
2. **合并代码段**：链接器将多个目标文件（可能来自不同的源文件）合并成一个单一的可执行文件。这包括合并代码段、数据段和资源。
    
3. **库函数链接**：大多数程序都会使用库中的函数（如标准库函数）。链接器将这些库函数的实现链接到最终的可执行文件中。
    
4. **内存分配**：链接器确定程序中各个部分在内存中的布局，包括代码、数据、堆和栈的位置。
    
5. **生成可执行文件**：最终，链接器生成一个可执行文件，这个文件包含了程序的所有代码和数据，可以直接在操作系统上运行。
## 16进制转2进制
每个十六进制数字可以直接转换为一个四位的二进制数。

十六进制数字与二进制数字的对应关系如下：

- 0 -> 0000
- 1 -> 0001
- 2 -> 0010
- 3 -> 0011
- 4 -> 0100
- 5 -> 0101
- 6 -> 0110
- 7 -> 0111
- 8 -> 1000
- 9 -> 1001
- A -> 1010
- B -> 1011
- C -> 1100
- D -> 1101
- E -> 1110
- F -> 1111
## 计算机如何计算+-* /
### 减法
在计算机中，减法是通过加法实现的，具体方法是使用二补数.
1. 求二补数

二补数是通过取反（将所有的1变为0，所有的0变为1）和加1来得到的。这个过程可以分两步完成：

- **取反**：将操作数的每一位二进制数取反。如果操作数是正数，直接取反；如果操作数是负数，先取其绝对值，然后取反。
- **加1**：在取反的结果上加1。

 2. 加法运算

将原数（被减数）与减数的二补数相加。这个加法运算实际上就是将两个数相加，包括处理进位。
### 乘法
假设我们要计算两个二进制数 A 和 B 的乘积：

1. **初始化结果**：创建一个结果变量，初始值为0。
    
2. **遍历乘数 B 的每一位**：
    
    - 从最低位（最右边）到最高位（最左边）。
3. **检查每一位**：
    
    - 如果 B 的当前位是1，那么将 A 左移与当前位对应的位数（从0开始计数），然后将这个值加到结果变量上。
    - 如果 B 的当前位是0，那么不进行任何操作。
4. **累加**：重复上述步骤，直到遍历完 B 的所有位。
    
5. **输出结果**：结果变量的最终值就是乘积。
计算二进制数 `A = 1011`（十进制中的11）和 `B = 1101`（十进制中的13）的乘积
- 创建一个结果变量，初始值为0
- B 的位从右到左是：1, 0, 1, 1
- **第一位（最右边）**：1
	- - 将 A 左移0位：`1011`
	- 加到结果上：结果=0+1011=1011结果=0+1011=1011
- **第二位**：0
    - 将 A 左移1位：`10110`
    - 不加到结果上（因为 B 的当前位是0）。
- **第三位**：1
    - 将 A 左移2位：`101100`
    - 加到结果上：结果=1011+101100=111011结果=1011+101100=111011
- **第四位（最左边）**：1
    - 将 A 左移3位：`1011000`
    - 加到结果上：结果=111011+1011000=10011011结果=111011+1011000=10011011
### 除法

二进制方法计算除法 a / c，其中 c 可以表示为两个质数 p 和 q 的乘积。实际上他就是 a * 2^n / c 并且移位，并且我们可以提前建立一张表存储2^n / c的值
## 十六小数转二进制
将十六进制小数 1A3.B 转换为二进制：

#### 整数部分：1A3

- 1 -> 0001
- A -> 1010
- 3 -> 0011

连接起来：0001 1010 0011

#### 小数部分：.B

- B -> 1011

连接起来：.1011

### 最终结果

组合整数和小数部分的二进制表示：

1A3.B=0001 1010 0011.1011

因此，十六进制小数 1A3.B的二进制表示是 0001 1010 0011.1011
### 浮点数的保存
以单精度为例，32位浮点数的组成如下：

- 第1位：符号位（S）
- 接下来的8位：指数部分（E）
- 最后的23位：尾数部分（M）

整体格式可以表示为：
S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMMM
#### 计算方法

1. **符号位**：直接存储数的符号。
2. **指数**：存储时使用偏移值（Bias），单精度的 Bias 为127，实际指数 = 存储指数 - Bias。
3. **尾数**：
    
    - 尾数部分存储的是有效数字，但不包括最高位的1（在规格化数中，尾数的首位总是1，隐含不存储）。
    - 因此，实际尾数 = 1.MMMMMMMMMMMMMMMMMMMMMMMM...（二进制）
##### 0001 1010 0011.1011的保存
1. **符号位（S）**：由于该数是正数，所以符号位为 `0`。
    
2. **规格化**：将整数部分转换为1.xxxx的形式。
    
    1.00110100011... × 2^8`（在二进制小数点后补0直到达到23位尾数）
    
3. **计算指数**：实际指数为8，IEEE 754单精度格式的偏移值（Bias）为127。
    
    存储指数 = 实际指数 + 偏移值 = 8 + 127 = 135，二进制表示为 `10000111`。
    
4. **计算尾数**：尾数部分为 `00110100011...`（取小数点后23位，如果小数部分位数不足，则在末尾补0）。
5. 010000111 00110100011 0 0 0 0 0 0 0 0 0 0 0 0